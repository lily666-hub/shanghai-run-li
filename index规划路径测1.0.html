<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ğŸƒâ€â™€ï¸ æ™ºèƒ½è·‘æ­¥å¯¼èˆªä¸è¯­éŸ³æ’­æŠ¥</title>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px 15px;
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      font-family: "Microsoft Yahei";
      z-index: 1000;
    }
  </style>
  <script src="https://webapi.amap.com/maps?v=2.0&key=e80dae89effb8a8a89f9e178be2974a3"></script>
</head>
<body>
  <div id="info">ğŸƒ è·‘æ­¥å¯¼èˆªå¯åŠ¨ä¸­ï¼Œæ­£åœ¨å®šä½...</div>
  <div id="map"></div>

  <script>
    let map, userPos, waypoints = [];
    let visited = new Set();
    // ===== å…¨å±€ overlays å’Œåˆ°è¾¾æ§åˆ¶ =====
    let overlays = [];         // å­˜æ”¾ marker / polylineï¼Œæ–¹ä¾¿æ¸…ç†
    let arrivalEnabled = false; // åœ¨ç”¨æˆ·çœŸæ­£ç§»åŠ¨åæ‰å…è®¸è§¦å‘åˆ°è¾¾æ’­æŠ¥
let lastUserPos = null;     // è®°å½•ä¸Šä¸€æ¬¡ä½ç½®ï¼Œç”¨äºåˆ¤å®šæ˜¯å¦ç§»åŠ¨

    // ========== åˆå§‹åŒ–åœ°å›¾ ==========
    map = new AMap.Map("map", { zoom: 15 });

    // ========== ç¬¬ä¸€æ­¥ï¼šè·å–ç”¨æˆ·å½“å‰ä½ç½® ==========
    AMap.plugin("AMap.Geolocation", function() {
      const geo = new AMap.Geolocation({
        enableHighAccuracy: true,
        timeout: 10000,
        showButton: false,
        showMarker: true,
        panToLocation: true
      });
      map.addControl(geo);

      geo.getCurrentPosition((status, result) => {
        if (status === 'complete') {
          userPos = result.position;
          document.getElementById("info").innerText = "âœ… å®šä½æˆåŠŸï¼Œæ­£åœ¨ç”Ÿæˆè·‘æ­¥è·¯çº¿...";
          generateDynamicRoute(userPos.lat, userPos.lng);
        } else {
          document.getElementById("info").innerText = "âš ï¸ å®šä½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™";
        }
      });
    });

 

// ========== ç¬¬äºŒæ­¥ï¼ˆæ›¿æ¢ï¼‰: åŸºäºå½“å‰ä½ç½®ä¸ AI ç»“æœç¡®å®šèµ·ç‚¹ï¼ˆä¿è¯èµ·ç‚¹åœ¨ç”¨æˆ· 100m å†…ï¼‰ï¼Œå…¶ä½™ä¿ç•™ AI è§„åˆ’ ==========
function generateDynamicRoute(lat, lng) {
  const user = { name: "èµ·ç‚¹(ä½ )", lat: lat, lng: lng, desc: "ä½ çš„å½“å‰ä½ç½®ï¼ˆå·²ä½œä¸ºèµ·ç‚¹ï¼‰" };

  // æ¸…ç†æ—§è¦†ç›–ç‰©
  overlays.forEach(o => o.setMap && o.setMap(null));
  overlays = [];
  visited.clear();
  arrivalEnabled = false;
  lastUserPos = { lat, lng };

  // è·å– aiPlanï¼ˆç¤ºä¾‹å˜é‡ï¼ŒçœŸå®é¡¹ç›®è¯·ç”¨ fetch è·å–ï¼‰
  if (typeof aiPlan !== 'undefined' && aiPlan.waypoints && aiPlan.waypoints.length) {
    const aiFirst = aiPlan.waypoints[0];
    const d = getDistance(lat, lng, aiFirst.lat, aiFirst.lng);

    if (d <= 100) {
      // AI çš„ç¬¬ä¸€ä¸ªç‚¹å°±åœ¨ç”¨æˆ· 100m å†… -> ä½¿ç”¨ AI èµ·ç‚¹ï¼ˆå°Šé‡AIï¼‰
      waypoints = aiPlan.waypoints.slice();
      console.log(`AI èµ·ç‚¹è·ç¦»ç”¨æˆ· ${Math.round(d)}mï¼Œä½¿ç”¨ AI èµ·ç‚¹ä½œä¸ºèµ·ç‚¹ã€‚`);
      document.getElementById("info").innerText = `âœ… ä½¿ç”¨ AI èµ·ç‚¹ï¼ˆè·ä½  ${Math.round(d)}mï¼‰ï¼Œç”Ÿæˆè·¯çº¿ä¸­...`;
    } else {
      // AI ç¬¬ä¸€ç‚¹ä¸åœ¨ 100m å†… -> æŠŠç”¨æˆ·æ’ä¸ºé¦–ä½ï¼Œä¿ç•™ AI åç»­ç‚¹
      waypoints = [ user, ...aiPlan.waypoints ];
      console.log(`AI èµ·ç‚¹è·ç¦»ç”¨æˆ· ${Math.round(d)}mï¼Œå·²å°†ç”¨æˆ·è®¾ä¸ºèµ·ç‚¹ï¼ŒAI å…¶ä½™ç‚¹ä¿ç•™ã€‚`);
      document.getElementById("info").innerText = `âœ… ä»¥ä½ ä¸ºèµ·ç‚¹ (è· AI èµ·ç‚¹ ${Math.round(d)}m)ï¼Œç”Ÿæˆè·¯çº¿ä¸­...`;
    }
  } else {
    // å›é€€ï¼šè‹¥æ²¡æœ‰ AI è¾“å‡ºï¼Œç”Ÿæˆä¸€ä¸ªç¤ºä¾‹è¿œç»ˆç‚¹ï¼ˆç»ˆç‚¹ä¸æ˜¯ç´§é‚»ç”¨æˆ·ï¼‰
    const randomOffset = () => (Math.random() - 0.5) * 0.0015; // çº¦ Â±150m
    waypoints = [
      user,
      { name: "æœ¬åœ°è§‚æ™¯A", lat: lat + randomOffset(), lng: lng + randomOffset(), desc: "æœ¬åœ°ç¤ºä¾‹è§‚æ™¯ç‚¹" },
      { name: "æœ¬åœ°ç»ˆç‚¹", lat: lat + 0.009 + Math.abs(randomOffset()), lng: lng + 0.009 + Math.abs(randomOffset()), desc: "æœ¬åœ°ç¤ºä¾‹ç»ˆç‚¹ï¼ˆçº¦1km+ï¼‰" }
    ];
    document.getElementById("info").innerText = "âš ï¸ æœªæ£€æµ‹åˆ° AI è·¯çº¿ï¼Œå·²ç”Ÿæˆæœ¬åœ°ç¤ºä¾‹è·¯çº¿ï¼ˆç»ˆç‚¹è¿œäº100mï¼‰ã€‚";
    console.log("æœªæä¾› aiPlanï¼Œä½¿ç”¨å›é€€æœ¬åœ°è·¯çº¿ç¤ºä¾‹ã€‚");
  }

  // åœ¨åœ°å›¾ä¸Šæ·»åŠ  markers
  waypoints.forEach(p => {
    const m = new AMap.Marker({
      position: [p.lng, p.lat],
      map: map,
      title: p.name,
      content: `<div style="background:#007bff;color:#fff;padding:2px 6px;border-radius:4px">${p.name}</div>`
    });
    overlays.push(m);
  });

  // è°ƒç”¨åˆ†æ®µè§„åˆ’å¹¶ç»˜åˆ¶ï¼ˆé€‚åˆé•¿è·ç¦»ï¼‰
  drawRouteSegments();
}

// ========== ç¬¬ä¸‰æ­¥ï¼šå¯¹æ¯ä¸€å¯¹ consecutive waypoints åšåˆ†æ®µè§„åˆ’å¹¶é€‰æ‹©â€œè¾ƒä¼˜â€è·¯å¾„ ==========
function drawRouteSegments() {
  if (!waypoints || waypoints.length < 2) {
    document.getElementById("info").innerText = "âš ï¸ æ— æœ‰æ•ˆé€”å¾„ç‚¹";
    return;
  }

  const segments = [];
  for (let i = 0; i < waypoints.length - 1; i++) {
    const d = getDistance(waypoints[i].lat, waypoints[i].lng, waypoints[i+1].lat, waypoints[i+1].lng);
    if (d < 8) continue; // è·ç¦»å¤ªçŸ­çš„æ®µè·³è¿‡
    segments.push({ from: waypoints[i], to: waypoints[i+1], idx: i });
  }

  const CONCURRENCY = 3;
  let running = 0, ptr = 0;

  function next() {
    if (ptr >= segments.length && running === 0) {
      document.getElementById("info").innerText = "âœ… å…¨éƒ¨è·¯æ®µç”Ÿæˆå®Œæ¯•ï¼Œå¼€å§‹å¯¼èˆª";
      return;
    }
    while (running < CONCURRENCY && ptr < segments.length) {
      const seg = segments[ptr++];
      running++;
      AMap.plugin(['AMap.Driving'], function() {
        const driving = new AMap.Driving({ map: map, policy: AMap.DrivingPolicy.LEAST_TIME });
        driving.search(
          new AMap.LngLat(seg.from.lng, seg.from.lat),
          new AMap.LngLat(seg.to.lng, seg.to.lat),
          { waypoints: [], extensions: 'all' },
          function(status, result) {
            running--;
            if (status === 'complete' && result && result.routes && result.routes.length) {
              const paths = result.routes[0].paths || [];
              let bestPath = paths[0];
              for (const p of paths) {
                if (p.steps && bestPath.steps && p.steps.length < bestPath.steps.length) bestPath = p;
              }
              if (bestPath && bestPath.steps) {
                const pts = bestPath.steps.map(s => s.polyline)
                  .join(';').split(';')
                  .map(pair => pair.split(',').map(Number));
                const poly = new AMap.Polyline({
                  path: pts,
                  strokeColor: seg.idx % 2 === 0 ? '#0091ff' : '#00c853',
                  strokeWeight: 4,
                  map: map
                });
                overlays.push(poly);
              }
            }
            next();
          }
        );
      });
    }
  }
  next();
}

// ========== ç¬¬å››æ­¥ï¼šå¼€å§‹å®æ—¶å®šä½ç›‘å¬ï¼ˆç§»åŠ¨ >5m åå¯ç”¨åˆ°è¾¾ï¼‰ ==========
function startPositionWatch() {
  AMap.plugin("AMap.Geolocation", function() {
    const geo = new AMap.Geolocation({ enableHighAccuracy: true, timeout: 10000 });
    geo.watchPosition((status, result) => {
      if (status === 'complete') {
        const pos = result.position;
        if (!arrivalEnabled) {
          const moved = lastUserPos ? getDistance(lastUserPos.lat, lastUserPos.lng, pos.lat, pos.lng) : 0;
          if (moved > 5) {
            arrivalEnabled = true;
            console.log('æ£€æµ‹åˆ°ç§»åŠ¨ >5mï¼Œå¯ç”¨åˆ°è¾¾è§¦å‘');
          } else {
            lastUserPos = { lat: pos.lat, lng: pos.lng };
          }
        }
        handlePosition(pos);
      }
    });
  });
}

// ========== åˆ°è¾¾æ£€æµ‹ + è¯­éŸ³æ’­æŠ¥ï¼ˆä»…å½“ arrivalEnabled ä¸º true æ—¶æ‰è§¦å‘ï¼‰ ==========
function handlePosition(pos) {
  const userLat = pos.lat;
  const userLng = pos.lng;
  lastUserPos = { lat: userLat, lng: userLng };

  if (!arrivalEnabled) return;

  for (const p of waypoints) {
    const dist = getDistance(userLat, userLng, p.lat, p.lng);
    if (dist < 50 && !visited.has(p.name)) {
      visited.add(p.name);
      speak(`ä½ å·²åˆ°è¾¾ ${p.name}ã€‚${p.desc}`);
      document.getElementById("info").innerText = `ğŸ“ å·²åˆ°è¾¾ï¼š${p.name}`;
    }
  }
}


    // ========== Haversineå…¬å¼è®¡ç®—è·ç¦» ==========
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371000;
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // ========== è¯­éŸ³æ’­æŠ¥ ==========
    function speak(text) {
      if ('speechSynthesis' in window) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'zh-CN';
        utter.rate = 1.0;
        speechSynthesis.speak(utter);
      }
    }
  </script>
</body>
</html>
