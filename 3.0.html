<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <meta charset="utf-8">
  <title>ğŸƒ æ™ºèƒ½è·‘æ­¥å¯¼èˆªï¼ˆå¯è§†åŒ–+è¯­éŸ³+æ­¥éª¤æç¤ºï¼‰</title>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px 14px;
      border-radius: 8px;
      font-family: "Microsoft Yahei";
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    #navPanel {
      position: absolute;
      right: 10px; top: 10px;
      width: 260px;
      height: 240px;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      font-family: "Microsoft Yahei";
      z-index: 1000;
    }
  </style>
  <script src="https://webapi.amap.com/maps?v=2.0&key=b4bbc4d6ac83b3431412e4f99c4d7b26"></script>
</head>
<body>
  <div id="map"></div>
  <div id="info">ğŸƒ æ­£åœ¨åŠ è½½å®šä½ä¸è·¯çº¿æ•°æ®...</div>
  <div id="navPanel"><b>ğŸ“œ å¯¼èˆªæç¤º</b><br>ç­‰å¾…è·¯çº¿è§„åˆ’...</div>

  <script>
    let map, userPos, waypoints = [];
    let navSteps = [];
    let currentStep = 0;
    const defaultPos = { lat: 31.2973, lng: 121.5035 }; // å¤æ—¦å¤§å­¦æ–‡ç§‘å›¾ä¹¦é¦†ï¼ˆé»˜è®¤ä¸­å¿ƒç‚¹ï¼‰

    map = new AMap.Map("map", { zoom: 15, center: [defaultPos.lng, defaultPos.lat] });

    // ---------- Step 1: å¤šå±‚å®šä½ ----------
    async function getUserLocation() {
      return new Promise((resolve) => {
        AMap.plugin("AMap.Geolocation", function () {
          const geo = new AMap.Geolocation({
            enableHighAccuracy: true, timeout: 10000, showButton: false, showMarker: true, panToLocation: true
          });
          map.addControl(geo);
          geo.getCurrentPosition((status, result) => {
            if (status === "complete") {
              console.log("âœ… é«˜å¾·å®šä½æˆåŠŸ");
              resolve(result.position);
            } else if (navigator.geolocation) {
              console.warn("âš ï¸ é«˜å¾·å®šä½å¤±è´¥ï¼Œå°è¯•æµè§ˆå™¨å®šä½...");
              navigator.geolocation.getCurrentPosition(
                (pos) => resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
                () => resolve(defaultPos),
                { enableHighAccuracy: true, timeout: 8000 }
              );
            } else {
              resolve(defaultPos);
            }
          });
        });
      });
    }

    // ---------- Step 2: è¯»å– CSV æ–‡ä»¶ ----------
    async function loadWaypoints() {
      try {
        const res = await fetch("waypoints.csv", { cache: "no-store" });
        if (!res.ok) throw new Error("CSV æ–‡ä»¶æ— æ³•è®¿é—®");
        const text = await res.text();
        const lines = text.trim().split(/\r?\n/);
        return lines.map(line => {
          const [name, lat, lng, desc = ""] = line.split(",");
          return { name, lat: parseFloat(lat), lng: parseFloat(lng), desc };
        });
      } catch (e) {
        console.warn("âš ï¸ æ— æ³•è¯»å– CSVï¼Œä½¿ç”¨é»˜è®¤æ¼”ç¤ºç‚¹");
        const offset = () => (Math.random() - 0.5) * 0.0015;
        return [
          { name: "èµ·ç‚¹(ä½ )", lat: defaultPos.lat, lng: defaultPos.lng, desc: "å¤æ—¦å¤§å­¦æ–‡ç§‘å›¾ä¹¦é¦†" },
          { name: "å¤æ—¦å—åŒºä½“è‚²åœº", lat: defaultPos.lat + offset(), lng: defaultPos.lng + offset(), desc: "æ ¡å›­è·‘æ­¥åœ°æ ‡" },
          { name: "å’Œå¹³å…¬å›­", lat: defaultPos.lat + 0.008, lng: defaultPos.lng + 0.008, desc: "è·¯çº¿ç»ˆç‚¹" }
        ];
      }
    }

    // ---------- Step 3: è·¯çº¿ç”Ÿæˆä¸ç»˜åˆ¶ ----------
    async function generateRoute() {
      userPos = await getUserLocation();
      waypoints = await loadWaypoints();

      // æ›¿æ¢èµ·ç‚¹ä¸ºå½“å‰ä½ç½®
      waypoints[0] = { name: "å½“å‰ä½ç½®ï¼ˆèµ·ç‚¹ï¼‰", lat: userPos.lat, lng: userPos.lng, desc: "å®æ—¶å®šä½èµ·ç‚¹" };

      document.getElementById("info").innerText = `âœ… æˆåŠŸåŠ è½½ ${waypoints.length} ä¸ªé€”å¾„ç‚¹ï¼Œæ­£åœ¨è§„åˆ’è·¯çº¿...`;

      // ç»˜åˆ¶æ‰€æœ‰é€”å¾„ç‚¹æ ‡è®°
      waypoints.forEach(p => {
        new AMap.Marker({
          position: [p.lng, p.lat],
          map: map,
          title: p.name,
          content: `<div style="background:#007bff;color:#fff;padding:2px 6px;border-radius:4px">${p.name}</div>`
        });
      });

      // è°ƒç”¨è·¯çº¿è§„åˆ’
      drawRoute();
    }

    // ---------- Step 4: ç»˜åˆ¶æ•´æ¡è·¯çº¿ï¼ˆå¯è§†åŒ– + è¯­éŸ³ + é¢æ¿ï¼‰ ----------
    // ---------- ä¿®æ”¹ï¼šæ›´å®Œå–„çš„è·¯çº¿è§„åˆ’å‡½æ•° ----------
function drawRoute() {
  if (waypoints.length < 2) {
    document.getElementById("info").innerText = "âš ï¸ é€”å¾„ç‚¹æ•°é‡ä¸è¶³ï¼Œæ— æ³•è§„åˆ’è·¯çº¿";
    provideFallbackNavigation();
    return;
  }
  
  AMap.plugin(["AMap.Driving"], function () {
    const driving = new AMap.Driving({
      map: map,
      policy: AMap.DrivingPolicy.LEAST_TIME, // å¯æ ¹æ®éœ€è¦ä¿®æ”¹ç­–ç•¥
      ferry: 1, // åŒ…å«è½®æ¸¡
      province: "æ²ª", // æŒ‡å®šåŸå¸‚ï¼ˆä¸Šæµ·ï¼‰ï¼Œæé«˜è§„åˆ’å‡†ç¡®æ€§
      showTraffic: false // å…³é—­å®æ—¶äº¤é€šï¼Œæé«˜å“åº”é€Ÿåº¦
    });

    // æ„é€ é€”å¾„ç‚¹æ•°ç»„
    const startPoint = new AMap.LngLat(waypoints[0].lng, waypoints[0].lat);
    const endPoint = new AMap.LngLat(waypoints[waypoints.length - 1].lng, waypoints[waypoints.length - 1].lat);
    const midPoints = waypoints.slice(1, -1).map(p => new AMap.LngLat(p.lng, p.lat));

    // è¶…æ—¶å¤„ç†
    const timeoutId = setTimeout(() => {
      document.getElementById("info").innerText = "âš ï¸ è·¯çº¿è§„åˆ’è¶…æ—¶ï¼Œå°è¯•ç®€åŒ–è·¯çº¿...";
      trySimplifiedRoute(); // è¶…æ—¶æ—¶å°è¯•ç®€åŒ–è·¯çº¿
    }, 15000);

    driving.search(startPoint, endPoint, { 
      waypoints: midPoints, 
      extensions: "all" // è·å–è¯¦ç»†ä¿¡æ¯
    }, (status, result) => {
      clearTimeout(timeoutId);
      
      if (status === "complete") {
        handleRouteResult(result);
      } else {
        handleRouteError(status, result);
      }
    });
  });
}

// ---------- æ–°å¢ï¼šå¤„ç†è·¯çº¿è§„åˆ’ç»“æœ ----------
function handleRouteResult(result) {
  if (result.routes && result.routes.length > 0) {
    const route = result.routes[0];
    navSteps = route.steps;
    
    // æ˜¾ç¤ºè·¯çº¿ä¿¡æ¯
    document.getElementById("info").innerHTML = 
      `âœ… è·¯çº¿è§„åˆ’å®Œæˆ<br>` +
      `<small>æ€»è·ç¦»: ${(route.distance / 1000).toFixed(1)}km | ` +
      `é¢„è®¡æ—¶é—´: ${Math.ceil(route.time / 60)}åˆ†é’Ÿ</small>`;
    
    showNavSteps(navSteps);
    speak("è·¯çº¿è§„åˆ’å®Œæˆï¼Œå¼€å§‹å¯¼èˆªã€‚");
    startRealtimeNav();
  } else {
    document.getElementById("info").innerHTML = 
      "âš ï¸ æœªæ‰¾åˆ°å¯è¡Œè·¯çº¿<br>" +
      "<small>æ­£åœ¨å°è¯•å¤‡é€‰æ–¹æ¡ˆ...</small>";
    tryAlternativeRoute();
  }
}

// ---------- æ–°å¢ï¼šå¤„ç†è·¯çº¿è§„åˆ’é”™è¯¯ ----------
function handleRouteError(status, result) {
  console.error("è·¯çº¿è§„åˆ’é”™è¯¯:", status, result);
  
  let errorMessage = "âš ï¸ è·¯çº¿è§„åˆ’å¤±è´¥";
  switch(status) {
    case "error":
      errorMessage = "âš ï¸ ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
      break;
    case "no_data":
      errorMessage = "âš ï¸ æ— æ³•è§„åˆ’å‡ºå¯è¡Œè·¯çº¿";
      break;
    case "complete":
      errorMessage = "âš ï¸ æœåŠ¡è¿”å›å¼‚å¸¸æ•°æ®";
      break;
    default:
      errorMessage = `âš ï¸ è·¯çº¿è§„åˆ’å¤±è´¥ (${status})`;
  }
  
  document.getElementById("info").innerText = errorMessage;
  
  // æ ¹æ®é”™è¯¯ç±»å‹å°è¯•ä¸åŒæ–¹æ¡ˆ
  if (status === "no_data" || status === "error") {
    tryAlternativeRoute();
  }
}

// ---------- æ–°å¢ï¼šå°è¯•å¤‡é€‰è·¯çº¿æ–¹æ¡ˆ ----------
function tryAlternativeRoute() {
  // æ–¹æ¡ˆ1: å°è¯•æ­¥è¡Œè·¯çº¿
  tryWalkingRoute();
  
  // æ–¹æ¡ˆ2: å¦‚æœæ­¥è¡Œä¹Ÿå¤±è´¥ï¼Œä½¿ç”¨ç›´çº¿è¿æ¥
  setTimeout(() => {
    if (!navSteps.length) {
      provideFallbackNavigation();
    }
  }, 3000);
}

// ---------- æ–°å¢ï¼šå°è¯•æ­¥è¡Œè·¯çº¿è§„åˆ’ ----------
function tryWalkingRoute() {
  AMap.plugin(["AMap.Walking"], function () {
    const walking = new AMap.Walking({
      map: map,
      policy: AMap.WalkingPolicy.LEAST_TIME
    });

    const startPoint = new AMap.LngLat(waypoints[0].lng, waypoints[0].lat);
    const endPoint = new AMap.LngLat(waypoints[waypoints.length - 1].lng, waypoints[waypoints.length - 1].lat);

    walking.search(startPoint, endPoint, (status, result) => {
      if (status === "complete" && result.routes && result.routes.length) {
        const route = result.routes[0];
        navSteps = route.steps;
        
        document.getElementById("info").innerHTML = 
          `ğŸš¶ ä½¿ç”¨æ­¥è¡Œè·¯çº¿<br>` +
          `<small>æ€»è·ç¦»: ${(route.distance / 1000).toFixed(1)}km</small>`;
        
        showNavSteps(navSteps);
        speak("å·²åˆ‡æ¢åˆ°æ­¥è¡Œè·¯çº¿å¯¼èˆª");
        startRealtimeNav();
      }
    });
  });
}

// ---------- æ–°å¢ï¼šç®€åŒ–è·¯çº¿ï¼ˆå‡å°‘é€”å¾„ç‚¹ï¼‰ ----------
function trySimplifiedRoute() {
  if (waypoints.length <= 3) {
    provideFallbackNavigation();
    return;
  }
  
  // åªä¿ç•™èµ·ç‚¹ã€ç»ˆç‚¹å’Œä¸­é—´1-2ä¸ªå…³é”®ç‚¹
  const simplifiedWaypoints = [
    waypoints[0],
    waypoints[Math.floor(waypoints.length / 2)], // ä¸­é—´ç‚¹
    waypoints[waypoints.length - 1]
  ];
  
  document.getElementById("info").innerText = "ğŸ”„ å°è¯•ç®€åŒ–è·¯çº¿...";
  
  // ä½¿ç”¨ç®€åŒ–åçš„é€”å¾„ç‚¹é‡æ–°è§„åˆ’
  const tempWaypoints = [...waypoints];
  waypoints = simplifiedWaypoints;
  
  setTimeout(() => {
    drawRoute();
    
    // æ¢å¤åŸå§‹é€”å¾„ç‚¹ï¼ˆç”¨äºæ˜¾ç¤ºæ ‡è®°ï¼‰
    setTimeout(() => {
      waypoints = tempWaypoints;
    }, 1000);
  }, 500);
}

    // ---------- Step 5: æ˜¾ç¤ºæ–‡å­—å¯¼èˆªé¢æ¿ ----------
    function showNavSteps(steps) {
      const panel = document.getElementById("navPanel");
      panel.innerHTML = "<b>ğŸ“œ å¯¼èˆªæç¤º</b><br>";
      steps.forEach((s, i) => {
        panel.innerHTML += `${i + 1}. ${s.instruction}<br>`;
      });
      document.getElementById("info").innerText = "âœ… å¯¼èˆªå·²ç”Ÿæˆï¼Œå¯å¼€å§‹ç§»åŠ¨";
    }

    // ---------- Step 6: å®æ—¶ä½ç½®æ›´æ–° ----------
    function startRealtimeNav() {
      AMap.plugin("AMap.Geolocation", function () {
        const geo = new AMap.Geolocation({ enableHighAccuracy: true, timeout: 10000 });
        geo.watchPosition((status, result) => {
          if (status === "complete") handlePosition(result.position);
        });
      });
    }

    // ---------- Step 7: åˆ°è¾¾æ£€æµ‹ + ä¸‹ä¸€æ­¥æ’­æŠ¥ ----------
    function handlePosition(pos) {
      if (!navSteps.length) return;
      const step = navSteps[currentStep];
      if (!step) return;
      const [lng, lat] = step.end_location.split(",").map(Number);
      const dist = getDistance(pos.lat, pos.lng, lat, lng);

      document.getElementById("info").innerText = `ğŸš¶ è·ç¦»ä¸‹ä¸€æŒ‡ä»¤ç‚¹ ${Math.round(dist)} ç±³`;

      if (dist < 30) {
        speak(step.instruction);
        document.getElementById("navPanel").innerHTML =
          `<b>ğŸ“ å½“å‰æŒ‡ä»¤ï¼š</b><br>${step.instruction}<br><br><small>å·²å®Œæˆ ${currentStep + 1}/${navSteps.length}</small>`;
        currentStep++;
      }
    }

    // ---------- Step 8: å·¥å…·å‡½æ•° ----------
    function getDistance(lat1, lng1, lat2, lng2) {
      const R = 6371000, toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLng = toRad(lng2 - lng1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function speak(text) {
      if ("speechSynthesis" in window) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "zh-CN";
        utter.rate = 1.0;
        speechSynthesis.speak(utter);
      }
    }

    // ğŸš€ å¯åŠ¨æµç¨‹
    generateRoute();
  </script>
</body>
</html>
