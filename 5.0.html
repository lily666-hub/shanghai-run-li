<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ğŸƒ æ™ºèƒ½è·‘æ­¥å¯¼èˆªï¼ˆREST æ­¥è¡Œ APIï¼Œå¤šé€”å¾„ç‚¹ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      border-radius: 8px;
      font-family: "Microsoft Yahei", Arial;
      box-shadow: 0 0 6px rgba(0,0,0,0.25);
      z-index: 1000;
      max-width: 340px;
    }
    #navPanel {
      position: absolute;
      right: 10px; top: 10px;
      width: 360px;
      height: 420px;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      font-family: "Microsoft Yahei", Arial;
      z-index: 1000;
    }
    .small { font-size: 12px; color: #555; }
    #controls { position:absolute; left:10px; bottom:10px; z-index:1000; background:rgba(255,255,255,0.95); padding:8px; border-radius:8px; box-shadow:0 0 6px rgba(0,0,0,0.2);}
    button { margin-right:6px; padding:6px 8px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer;}
    input[type="file"] { display:inline-block; }
  </style>

  <!-- ç¯å¢ƒå˜é‡é…ç½® -->
  <script src="/env-config.js"></script>
  
  <!-- åœ°å›¾ JS åŠ¨æ€åŠ è½½ -->
  <script>
    // åŠ¨æ€åŠ è½½é«˜å¾·åœ°å›¾JS SDK
    (function() {
      const amapKey = window.VITE_AMAP_API_KEY || 'b4bbc4d6ac83b3431412e4f99c4d7b26';
      const script = document.createElement('script');
      script.src = `https://webapi.amap.com/maps?v=2.0&key=${amapKey}`;
      document.head.appendChild(script);
    })();
  </script>
</head>
<body>
  <div id="map"></div>
  <div id="info">ğŸƒ åˆå§‹åŒ–ä¸­â€¦ï¼ˆå•å‡»åœ°å›¾å¯æ·»åŠ é€”å¾„ç‚¹ï¼Œæˆ–ä¸Šä¼  waypoints.csvï¼‰</div>
  <div id="navPanel"><b>ğŸ“œ å¯¼èˆªæç¤º</b><br><span class="small">ç­‰å¾…è·¯çº¿è§„åˆ’...</span></div>

  <div id="controls">
    <button id="btnUseSample">åŠ è½½ç¤ºä¾‹ 5 ç‚¹</button>
    <label style="margin-right:6px">
      ä¸Šä¼  CSV <input id="csvfile" type="file" accept=".csv" />
    </label>
    <button id="btnPlan">å¼€å§‹è§„åˆ’</button>
    <button id="btnClear">æ¸…é™¤é€”å¾„ç‚¹</button>
    <span class="small" style="display:block;margin-top:6px">æç¤ºï¼šä¸Šä¼  CSV æ¯è¡Œæ ¼å¼ï¼šname,lat,lng,desc</span>
  </div>

  <script>
    // ---------- é…ç½®ï¼šä»ç¯å¢ƒå˜é‡è·å– REST key ----------
    const AMAP_REST_KEY = window.VITE_AMAP_REST_KEY || 'b4bbc4d6ac83b3431412e4f99c4d7b26'; // ä»ç¯å¢ƒå˜é‡è·å–æˆ–ä½¿ç”¨é»˜è®¤å€¼
    // JS SDK key åœ¨åœ°å›¾è„šæœ¬ src ä¸­ä¹Ÿå¯æ›¿æ¢

    // ---------- å…¨å±€çŠ¶æ€ ----------
    let map = null; // å»¶è¿Ÿåˆå§‹åŒ–
    let waypoints = []; // [{name, lat, lng, desc, marker}]
    let markers = [];
    let navSteps = [];   // [{instruction, path:[[lng,lat],...]}]
    let fullPath = [];   // [[lng,lat], ...]
    let polyline = null;
    let stepIndex = 0;
    let watchId = null;

    const MIN_WP = 5; // è‡³å°‘ 5 ä¸ªé€”å¾„ç‚¹

    // ---------- å·¥å…·å‡½æ•° ----------
    function speak(text) {
      if ("speechSynthesis" in window) {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "zh-CN"; u.rate = 1.0;
        speechSynthesis.speak(u);
      }
    }

    function parseCSVText(text) {
      return text.trim().split(/\r?\n/).map(line => {
        const parts = line.split(",").map(s => s.trim());
        return { name: parts[0] || 'ç‚¹', lat: parseFloat(parts[1]), lng: parseFloat(parts[2]), desc: parts.slice(3).join(",") || '' };
      }).filter(p => !isNaN(p.lat) && !isNaN(p.lng));
    }

    function addWaypoint(pt) {
      // pt: {name, lat, lng, desc}
      if (!map) {
        console.warn('åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ·»åŠ é€”å¾„ç‚¹');
        return;
      }
      const i = waypoints.length + 1;
      const marker = new AMap.Marker({
        position: [pt.lng, pt.lat],
        map,
        title: `${i}. ${pt.name}`,
        content: `<div style="background:#007bff;color:#fff;padding:4px 8px;border-radius:6px;font-size:12px">${i}. ${pt.name}</div>`
      });
      waypoints.push({...pt, marker});
      markers.push(marker);
      updateInfo(`å·²æ·»åŠ é€”å¾„ç‚¹ ${waypoints.length}ï¼š${pt.name}`);
    }

    function clearWaypoints() {
      waypoints.forEach(w => { if (w.marker) w.marker.setMap(null); });
      waypoints = []; markers = [];
      if (polyline) { polyline.setMap(null); polyline = null; }
      navSteps = []; fullPath = []; stepIndex = 0;
      updateInfo("å·²æ¸…é™¤æ‰€æœ‰é€”å¾„ç‚¹");
      renderNavPanel();
    }

    function updateInfo(text) { document.getElementById("info").innerText = text; }

    function normalizePolylineString(polylineStr) {
      // "lng,lat;lng,lat;..."
      if (!polylineStr) return [];
      return polylineStr.split(";").map(p => {
        const [lng, lat] = p.split(",").map(Number);
        return [lng, lat];
      }).filter(Boolean);
    }

    function appendSegmentToFullPath(segmentPts) {
      if (!segmentPts || segmentPts.length === 0) return;
      // å»é‡è¿æ¥ï¼šå¦‚æœ fullPath æœ€åä¸€ç‚¹ä¸ segmentPts ç¬¬ä¸€ç›¸åŒåˆ™å»æ‰é¦–
      if (fullPath.length > 0) {
        const last = fullPath[fullPath.length - 1];
        const firstSeg = segmentPts[0];
        if (Math.abs(last[0]-firstSeg[0]) < 1e-6 && Math.abs(last[1]-firstSeg[1]) < 1e-6) {
          segmentPts = segmentPts.slice(1);
        }
      }
      fullPath.push(...segmentPts);
    }

    function drawFullPolyline() {
      if (!map) {
        console.warn('åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•ç»˜åˆ¶è·¯çº¿');
        return;
      }
      if (polyline) polyline.setMap(null);
      if (!fullPath || fullPath.length === 0) {
        updateInfo("âš ï¸ æ²¡æœ‰è·¯å¾„å¯ç»˜åˆ¶");
        return;
      }
      polyline = new AMap.Polyline({
        path: fullPath,
        map,
        showDir: true,
        strokeWeight: 5,
        strokeColor: "#00A8FF",
        lineJoin: "round"
      });
      map.setFitView([polyline]);
      const km = (calcTotalDistance(fullPath) / 1000).toFixed(2);
      updateInfo(`ğŸƒ è·¯çº¿å·²ç»˜åˆ¶ï¼Œé•¿åº¦ ${km} kmï¼ˆä½¿ç”¨å®˜æ–¹æ­¥è¡Œè§„åˆ’ï¼‰`);
    }

    function calcTotalDistance(path) {
      function getDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000, toRad = d => d * Math.PI / 180;
        const dLat = toRad(lat2-lat1), dLng = toRad(lng2-lng1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      }
      let d = 0;
      for (let i=1;i<path.length;i++){
        const [lng1,lat1] = path[i-1];
        const [lng2,lat2] = path[i];
        d += getDistance(lat1,lng1,lat2,lng2);
      }
      return d;
    }

    // ---------- åœ°å›¾ç‚¹å‡»åŠ å…¥é€”å¾„ç‚¹ï¼ˆå·²ç§»è‡³åˆå§‹åŒ–å‡½æ•°ä¸­ï¼‰ ----------

    // ---------- CSV ä¸Šä¼ æ”¯æŒ ----------
    document.getElementById('csvfile').addEventListener('change', async (ev) => {
      const f = ev.target.files[0];
      if (!f) return;
      const txt = await f.text();
      const pts = parseCSVText(txt);
      if (!pts.length) { alert('CSV è§£æå¤±è´¥æˆ–æ— æœ‰æ•ˆç‚¹'); return; }
      clearWaypoints();
      pts.forEach(p => addWaypoint(p));
      // å¦‚æœ < MIN_WP åˆ™è¡¥è¶³ï¼ˆæ¥ä¸‹æ¥ä¼šè‡ªåŠ¨æ’å€¼ä¿è¯ >= MIN_WPï¼‰
      renderNavPanel();
    });

    // ---------- åŠ è½½ç¤ºä¾‹ 5 ç‚¹ ----------
    document.getElementById('btnUseSample').addEventListener('click', () => {
      clearWaypoints();
      // ç¤ºä¾‹å›ºå®š5ç‚¹ï¼ˆå¯æŒ‰éœ€ä¿®æ”¹ï¼‰
      const base = { lat: 31.2973, lng: 121.5035 };
      const arr = [
        { name: 'èµ·ç‚¹', lat: base.lat, lng: base.lng, desc: 'èµ·ç‚¹' },
        { name: 'ç‚¹A', lat: base.lat + 0.0032, lng: base.lng + 0.0016, desc: '' },
        { name: 'ç‚¹B', lat: base.lat + 0.0051, lng: base.lng + 0.004, desc: '' },
        { name: 'ç‚¹C', lat: base.lat + 0.0038, lng: base.lng + 0.0065, desc: '' },
        { name: 'ç»ˆç‚¹', lat: base.lat + 0.008, lng: base.lng + 0.0075, desc: '' }
      ];
      arr.forEach(p => addWaypoint(p));
      renderNavPanel();
    });

    // ---------- æ¸²æŸ“å¯¼èˆªé¢æ¿ï¼ˆä¸¤éƒ¨åˆ†ï¼šå…¨éƒ¨æŒ‡ä»¤ + å½“å‰/ä¸‹ä¸€æ­¥ï¼‰ ----------
    function renderNavPanel() {
      const panel = document.getElementById('navPanel');
      panel.innerHTML = '<b>ğŸ“œ å¯¼èˆªæç¤º</b><br>';
      panel.innerHTML += `<div class="small">é€”å¾„ç‚¹æ•°ï¼š${waypoints.length}ï¼ˆè‡³å°‘ ${MIN_WP}ï¼‰</div><hr>`;
      // show waypoints list
      panel.innerHTML += '<div style="font-weight:600">é€”å¾„ç‚¹ï¼ˆé¡ºåºï¼‰</div>';
      waypoints.forEach((w,i) => {
        panel.innerHTML += `<div style="margin-bottom:6px">${i+1}. ${w.name} (${w.lat.toFixed(5)}, ${w.lng.toFixed(5)})</div>`;
      });
      panel.innerHTML += '<hr>';
      // show current and next
      panel.innerHTML += '<div style="font-weight:600">å½“å‰/æ¥ä¸‹æ¥æŒ‡ä»¤</div>';
      if (navSteps.length === 0) {
        panel.innerHTML += '<div class="small">å°šæœªè§„åˆ’è·¯çº¿</div>';
      } else {
        const cur = navSteps[stepIndex] || null;
        if (cur) {
          panel.innerHTML += `<div style="margin-bottom:8px"><b>å½“å‰ï¼š</b>${cur.instruction}</div>`;
        } else panel.innerHTML += '<div>å·²å®Œæˆå…¨éƒ¨æŒ‡ä»¤</div>';
        panel.innerHTML += '<div style="font-weight:600;margin-top:8px">å®Œæ•´æŒ‡ä»¤åˆ—è¡¨</div>';
        // full list
        navSteps.forEach((s,i) => {
          panel.innerHTML += `<div style="margin-bottom:6px">${i+1}. ${s.instruction}</div>`;
        });
        panel.innerHTML += `<div class="small">æ€»æŒ‡ä»¤æ•°ï¼š${navSteps.length}</div>`;
      }
    }

    // ---------- å¤„ç†å°‘äº MIN_WP è‡ªåŠ¨æ’ç‚¹ï¼ˆåœ¨æ¯å¯¹ç‚¹ä¹‹é—´çº¿æ€§æ’å€¼ï¼‰ ----------
    function ensureMinWaypoints() {
      if (waypoints.length >= MIN_WP) return;
      const need = MIN_WP - waypoints.length;
      // æŠŠç°æœ‰ç‚¹ä¸¤ä¸¤é—´å‡åŒ€æ’å…¥æ–°çš„ç‚¹ï¼ˆç®€å•ç­–ç•¥ï¼‰
      const generated = [];
      for (let i=0; generated.length < need; i = (i+1) % Math.max(1, waypoints.length-1)) {
        const a = waypoints[i];
        const b = waypoints[i+1] || waypoints[0];
        const midLat = (a.lat + b.lat)/2 + (Math.random()-0.5)*1e-5;
        const midLng = (a.lng + b.lng)/2 + (Math.random()-0.5)*1e-5;
        generated.push({ name: `è¡¥ç‚¹${generated.length+1}`, lat: midLat, lng: midLng, desc: 'è‡ªåŠ¨è¡¥è¶³' });
      }
      generated.forEach(p => addWaypoint(p));
      updateInfo(`è·¯å¾„ç‚¹ä¸è¶³å·²è‡ªåŠ¨è¡¥è¶³åˆ° ${waypoints.length} ä¸ª`);
    }

    // ---------- REST API: è·å–æŸä¸€æ®µæ­¥è¡Œè§„åˆ’ï¼ˆorigin & destination ä¸º lng,lat å­—ç¬¦ä¸²ï¼‰ ----------
    async function fetchWalkingSegment(originLngLat, destLngLat) {
      // originLngLat, destLngLat: "lng,lat" string
      const url = `https://restapi.amap.com/v3/direction/walking?origin=${originLngLat}&destination=${destLngLat}&key=${AMAP_REST_KEY}&extensions=base`;

      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!data || data.status !== '1') {
          console.warn('REST walking API è¿”å›å¤±è´¥', data);
          return null;
        }
        // data.route.paths[0] åŒ…å« paths, steps
        const pathObj = (data.route && data.route.paths && data.route.paths[0]) || null;
        return pathObj;
      } catch (e) {
        console.error('fetchWalkingSegment error', e);
        return null;
      }
    }

    // ---------- æŒ‰é€”å¾„ç‚¹åˆ†æ®µè¯·æ±‚ REST API å¹¶æ‹¼æ¥è·¯çº¿ ----------
    async function planByRestWalking() {
      // æ¸…ç©ºå†å²
      navSteps = []; fullPath = []; stepIndex = 0;
      if (polyline) { polyline.setMap(null); polyline = null; }

      // è‹¥ä¸è¶³ MIN_WP è‡ªåŠ¨è¡¥è¶³
      if (waypoints.length < MIN_WP) ensureMinWaypoints();

      // é€æ®µè§„åˆ’
      for (let i = 0; i < waypoints.length - 1; i++) {
        const a = waypoints[i], b = waypoints[i+1];
        updateInfo(`è§„åˆ’ç¬¬ ${i+1} æ®µï¼š${a.name} â†’ ${b.name}ï¼ˆä½¿ç”¨å®˜æ–¹æ­¥è¡Œ APIï¼‰`);
        const origin = `${a.lng.toFixed(6)},${a.lat.toFixed(6)}`;
        const destination = `${b.lng.toFixed(6)},${b.lat.toFixed(6)}`;
        const seg = await fetchWalkingSegment(origin, destination);
        if (seg) {
          // seg.steps æ¯ä¸ª step æœ‰ polyline å­—ç¬¦ä¸²
          if (seg.steps && seg.steps.length) {
            for (const s of seg.steps) {
              const pts = normalizePolylineString(s.polyline);
              appendSegmentToFullPath(pts);
              navSteps.push({ instruction: s.instruction || s.action || 'å‰è¿›', path: pts });
            }
          } else if (seg.polyline) {
            const pts = normalizePolylineString(seg.polyline);
            appendSegmentToFullPath(pts);
            navSteps.push({ instruction: `æ®µ ${i+1}`, path: pts });
          } else {
            // æ²¡æœ‰ polylineï¼Œé€€å›ä¸ºç›´çº¿
            const pts = [[a.lng, a.lat], [b.lng, b.lat]];
            appendSegmentToFullPath(pts);
            navSteps.push({ instruction: `ç›´çº¿ï¼ˆAPIæ— æ•°æ®ï¼‰ ${a.name}â†’${b.name}`, path: pts });
          }
        } else {
          // API å¤±è´¥ï¼šé€€å›ç›´çº¿è¿æ¥
          console.warn(`ç¬¬ ${i+1} æ®µæ­¥è¡Œè§„åˆ’å¤±è´¥ï¼Œä½¿ç”¨ç›´çº¿è¿æ¥`);
          const pts = [[a.lng, a.lat], [b.lng, b.lat]];
          appendSegmentToFullPath(pts);
          navSteps.push({ instruction: `ç›´çº¿ï¼ˆAPIå¤±è´¥ï¼‰ ${a.name}â†’${b.name}`, path: pts });
        }
      }

      // ç»˜åˆ¶ä¸å±•ç¤º
      drawFullPolyline();
      renderNavPanel();
      speak('è·¯çº¿è§„åˆ’å®Œæˆï¼Œå·²ç»˜åˆ¶åœ¨åœ°å›¾ä¸Šã€‚');
    }

    // ---------- normalize polyline string helper ----------
    function normalizePolylineString(polylineStr) {
      if (!polylineStr || typeof polylineStr !== 'string') return [];
      return polylineStr.split(';').map(s => {
        const [lng, lat] = s.split(',').map(Number);
        return [lng, lat];
      }).filter(p => !isNaN(p[0]) && !isNaN(p[1]));
    }

    // ---------- å®æ—¶å®šä½ä¸åˆ°è¾¾æ£€æµ‹ ----------
    function startRealtimeNav() {
      if (!navigator.geolocation) {
        alert('æµè§ˆå™¨ä¸æ”¯æŒå®šä½ï¼Œæ— æ³•è¿›è¡Œå®æ—¶å¯¼èˆª');
        return;
      }
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(pos => {
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        handlePosition({lat, lng});
      }, err => {
        console.warn('watchPosition error', err);
      }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 });
    }

    function handlePosition(pos) {
      updateInfo(`ğŸ“ å½“å‰ï¼š${pos.lat.toFixed(5)}, ${pos.lng.toFixed(5)}`);
      if (!navSteps || navSteps.length === 0) return;
      const step = navSteps[stepIndex];
      if (!step) return;
      const stepPts = step.path && step.path.length ? step.path : null;
      if (!stepPts || stepPts.length === 0) {
        speak(step.instruction || `å·²å®Œæˆç¬¬${stepIndex+1}æ­¥`);
        stepIndex++;
        renderNavPanel();
        return;
      }
      const last = stepPts[stepPts.length-1];
      const [lng, lat] = last;
      // compute distance
      function haversine(lat1,lng1,lat2,lng2){
        const R = 6371000, toRad = d => d*Math.PI/180;
        const dLat = toRad(lat2-lat1), dLng = toRad(lng2-lng1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      }
      const dist = haversine(pos.lat, pos.lng, lat, lng);
      document.getElementById('info').innerText = `ğŸš¶ è·ç¦»å½“å‰æŒ‡ä»¤ç»ˆç‚¹ ${Math.round(dist)} ç±³`;
      const arriveThreshold = 25; // å¯è°ƒæ•´
      if (dist <= arriveThreshold) {
        speak(step.instruction || `å·²åˆ°è¾¾ç¬¬${stepIndex+1}æ­¥`);
        stepIndex++;
        renderNavPanel();
      } else if (dist > 80) {
        // å¯è‡ªåŠ¨é‡è§„åˆ’ï¼Œè¿™é‡Œä»…æ˜¾ç¤ºæç¤ºï¼ˆä½ å¯ä»¥æŒ‰éœ€å¼€å¯è‡ªåŠ¨é‡è§„åˆ’ï¼‰
        // speak('æ³¨æ„ï¼šä½ åç¦»è·¯çº¿è¾ƒè¿œï¼Œå»ºè®®é‡è§„åˆ’ã€‚');
      }
    }

    // ---------- ç»‘å®šæŒ‰é’® ----------
    document.getElementById('btnPlan').addEventListener('click', async () => {
      if (!AMAP_REST_KEY || AMAP_REST_KEY === 'YOUR_REST_KEY_HERE') {
        alert('è¯·åœ¨ä»£ç é¡¶éƒ¨å°† AMAP_REST_KEY æ›¿æ¢ä¸ºä½ çš„ Web æœåŠ¡ API Keyï¼ˆRESTï¼‰');
        return;
      }
      if (waypoints.length < 2) {
        alert('è¯·å…ˆæ·»åŠ è‡³å°‘ 2 ä¸ªé€”å¾„ç‚¹ï¼ˆå»ºè®® >=5ï¼‰ï¼Œå¯ç‚¹å‡»åœ°å›¾æ·»åŠ æˆ–ä¸Šä¼  CSV æˆ–åŠ è½½ç¤ºä¾‹');
        return;
      }
      document.getElementById('btnPlan').disabled = true;
      await planByRestWalking();
      startRealtimeNav();
      document.getElementById('btnPlan').disabled = false;
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      clearWaypoints();
    });

    // ---------- åœ°å›¾åˆå§‹åŒ–å‡½æ•° ----------
    function initializeMap() {
      if (typeof AMap !== 'undefined') {
        map = new AMap.Map("map", { zoom: 15, center: [121.5035, 31.2973] });
        
        // æ·»åŠ åœ°å›¾ç‚¹å‡»äº‹ä»¶
        map.on('click', (e) => {
          const { lng, lat } = e.lnglat;
          const name = `ç‚¹${waypoints.length + 1}`;
          addWaypoint({ name, lat, lng, desc: 'æ‰‹åŠ¨æ·»åŠ ' });
        });
        
        updateInfo('åœ°å›¾åˆå§‹åŒ–å®Œæˆï¼Œå•å‡»åœ°å›¾å¯æ·»åŠ é€”å¾„ç‚¹');
        
        // é¡µé¢åŠ è½½æ—¶ï¼šå¯é»˜è®¤åŠ è½½ä¸€ä¸ªç¤ºä¾‹ï¼ˆå¯æ³¨é‡Šï¼‰
        //document.getElementById('btnUseSample').click();
        
        // åˆå§‹æ¸²æŸ“
        renderNavPanel();
      } else {
        // å¦‚æœAMapè¿˜æœªåŠ è½½ï¼Œç­‰å¾…100msåé‡è¯•
        setTimeout(initializeMap, 100);
      }
    }

    // ---------- ç­‰å¾…SDKåŠ è½½å®Œæˆååˆå§‹åŒ–åœ°å›¾ ----------
    if (typeof AMap !== 'undefined') {
      initializeMap();
    } else {
      // ç›‘å¬SDKåŠ è½½å®Œæˆ
      window.addEventListener('load', initializeMap);
    }

  </script>
</body>
</html>
